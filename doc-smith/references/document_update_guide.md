# 文档更新执行指南

## 三种反馈类型识别

### 1. 全局语义修改（Global Semantic Changes）

**识别特征：** 跨多个文档的规则、术语、风格变更。

**处理方式：**
1. 提取所有全局规则
2. 遍历 `.aigne/doc-smith/docs/` 下所有文档
3. 对每个文档应用规则
4. 保持修改的一致性

**典型模式：**
- 术语替换："blocklet" → "Blocklet"
- 风格调整：删除第一人称
- 格式统一：代码块添加语言标识

**来源：** 自然语言请求、Changeset 文件

### 2. 局部结构性重写（Structural Rewrite Requests）

**识别特征：** 需要补充、重写、重组特定章节。

**处理方式：**
1. 定位目标文档和章节
2. 读取相关源文件和上下文
3. 基于重写目标重新生成内容
4. 替换原有章节，确保前后衔接

**典型模式：**
- 补充内容："添加环境要求章节"
- 重组结构："合并分散的安装步骤"
- 增强说明："补充错误码说明"

**来源：** 自然语言请求、Changeset 文件

### 3. 直接内容改写（PATCH）

**识别特征：** 文档内的 `:::PATCH` 标记。

**处理方式：**
1. 扫描所有文档查找 `:::PATCH` 标记
2. 读取 PATCH 内的修改指令
3. 执行精确替换
4. 删除整个 PATCH 标记

**PATCH 标记格式：**
```markdown
::: PATCH
修改说明或新内容
:::
```

**来源：** 仅通过文档内标记（不会出现在 Changeset 文件中）

## 三种输入方式处理

### 方式 1：自然语言修改请求

**检测：** 用户直接描述修改需求，无文件路径，无 PATCH 标记提及。

**执行步骤：**
1. 分析请求，识别反馈类型
2. 确定影响范围（单文档 vs 多文档）
3. 按识别的类型执行修改
4. 记录所有修改的文件

### 方式 2：Changeset 文件

**检测：** 用户提供文件路径（通常是 `.md` 文件）。

**执行步骤：**
1. 读取 changeset 文件
2. 理解所有修改请求
3. 分类为全局修改、结构重写
4. 按优先级执行：全局修改 → 结构重写
5. 记录所有修改

**重要：**
- Changeset 只包含全局修改和结构重写，不包含 PATCH
- 格式自由，自然语言描述
- 参见 [changeset_schema.md](changeset_schema.md) 了解识别规则

### 方式 3：文档内 PATCH 标记

**检测：** 用户提到"PATCH 标记"或要求"应用 PATCH"。

**执行步骤：**
```bash
# 扫描所有文档
grep -r ":::PATCH" .aigne/doc-smith/docs/
```

对每个标记：
1. 读取 PATCH 内的修改指令
2. 理解并执行修改
3. 删除整个 `:::PATCH ... :::` 标记
4. 保存文档

**PATCH 标记格式：**
```markdown
::: PATCH
修改说明或新内容
:::
```

## 更新执行流程

### 步骤 1：检测文档状态

```bash
ls -la .aigne/doc-smith/docs/
```

- 不存在 → 告知用户使用生成流程（步骤 1-7）
- 存在 → 继续更新流程

### 步骤 2：识别输入类型

根据用户消息判断：
- 包含文件路径 → Changeset
- 提到"PATCH 标记"或"应用 PATCH" → PATCH 方式
- 其他 → 自然语言

如果不确定，询问用户。

### 步骤 3：解析更新请求

- **自然语言：** 分析并分类为全局修改、结构重写或 PATCH
- **Changeset：** 读取文件，提取全局修改和结构重写
- **PATCH 标记：** 扫描文档，查找所有 `:::PATCH`

### 步骤 4：应用修改

**执行优先级：** 全局修改 → 结构重写 → PATCH

**全局修改：**
```bash
# 获取所有文档
find .aigne/doc-smith/docs/ -name "*.md"
```
对每个文档：
- 读取内容
- 应用规则（替换、删除、添加）
- 保存修改

**结构重写：**
- 定位目标章节（使用标题或位置描述）
- 读取相关源文件（如果需要）
- 重新生成内容
- 替换章节

**PATCH：**
- 精确定位
- 直接替换
- 删除标记

### 步骤 5：展示变更摘要

格式：
```
已完成文档更新：

✓ 全局语义修改：N条规则应用到 M 个文档
  - 规则描述（N处修改）

✓ 结构重写：N个章节
  - 文档名: 章节名

✓ PATCH 应用：N处精确修改
  - 文档名: 修改描述

修改的文件：
  - 文件路径
  - ...
```

## 执行要点

1. **理解意图：** 仔细分析修改请求，确定类型和范围
2. **正确分类：** 准确识别是全局、重写还是 PATCH
3. **优先级：** 严格按"全局 → 重写 → PATCH"顺序，避免冲突
4. **一致性：** 全局修改必须应用到所有匹配位置
5. **批量执行：** 一次性处理，减少读写次数
6. **验证：** 修改后检查语法和链接
7. **清晰反馈：** 详细列出所有修改
8. **删除标记：** PATCH 应用后必须删除标记

## 常见场景参考

### 术语统一
```
请求："将所有 API 改为 API 接口"
类型：全局语义修改
执行：正则替换所有文档中的 "API" → "API 接口"
```

### 补充章节
```
请求："快速开始缺少环境要求"
类型：局部结构重写
执行：
  1. 打开 getting-started.md
  2. 在开头或指定位置添加"环境要求"章节
  3. 参考 package.json, README.md 生成内容
```

### 版本更新
```
请求："版本号改为 2.1"
类型：全局修改或 PATCH（根据数量）
执行：替换所有 "2.0" → "2.1"
```

## 错误处理

**位置不存在：** 展示最接近匹配，询问确认。

**修改冲突：** 说明冲突原因，询问优先级。

**结构不匹配：** 展示当前结构，询问如何处理。
